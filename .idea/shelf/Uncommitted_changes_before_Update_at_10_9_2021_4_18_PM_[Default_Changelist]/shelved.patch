Index: app/src/main/java/com/app/simoslogger/BTService.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.app.simoslogger\r\n\r\nimport android.app.*\r\nimport android.bluetooth.*\r\nimport android.bluetooth.le.ScanCallback\r\nimport android.bluetooth.le.ScanFilter\r\nimport android.bluetooth.le.ScanResult\r\nimport android.bluetooth.le.ScanSettings\r\nimport android.content.Context\r\nimport android.content.Intent\r\nimport android.os.Handler\r\nimport android.os.IBinder\r\nimport android.os.Looper\r\nimport android.os.ParcelUuid\r\nimport android.util.Log\r\nimport android.widget.Toast\r\nimport com.app.simoslogger.R\r\nimport java.io.BufferedWriter\r\nimport java.io.File\r\nimport java.io.FileWriter\r\nimport java.util.concurrent.ConcurrentLinkedQueue\r\nimport java.util.concurrent.Semaphore\r\n\r\n\r\n// Header we expect to receive on BLE packets\r\nclass BLEHeader {\r\n    var hdID: Int = BLE_HEADER_ID\r\n    var cmdFlags: Int = 0\r\n    var rxID: Int = BLE_HEADER_RX\r\n    var txID: Int = BLE_HEADER_TX\r\n    var cmdSize: Int = 0\r\n    var tickCount: Int = 0\r\n\r\n    fun isValid(): Boolean {\r\n        return hdID == BLE_HEADER_ID\r\n    }\r\n\r\n    fun toByteArray(): ByteArray {\r\n        val bArray = ByteArray(8)\r\n        bArray[0] = (hdID and 0xFF).toByte()\r\n        bArray[1] = (cmdFlags and 0xFF).toByte()\r\n        bArray[2] = (rxID and 0xFF).toByte()\r\n        bArray[3] = ((rxID and 0xFF00) shr 8).toByte()\r\n        bArray[4] = (txID and 0xFF).toByte()\r\n        bArray[5] = ((txID and 0xFF00) shr 8).toByte()\r\n        bArray[6] = (cmdSize and 0xFF).toByte()\r\n        bArray[7] = ((cmdSize and 0xFF00) shr 8).toByte()\r\n\r\n        return bArray\r\n    }\r\n\r\n    fun fromByteArray(bArray: ByteArray) {\r\n        hdID = bArray[0] and 0xFF\r\n        cmdFlags = bArray[1] and 0xFF\r\n        rxID = ((bArray[3] and 0xFF) shl 8) + (bArray[2] and 0xFF)\r\n        txID = ((bArray[5] and 0xFF) shl 8) + (bArray[4] and 0xFF)\r\n        cmdSize = ((bArray[7] and 0xFF) shl 8) + (bArray[6] and 0xFF)\r\n        tickCount = ((rxID  and 0xFFFF) shl 16) + (txID  and 0xFFFF)\r\n    }\r\n}\r\n\r\nclass BTService: Service() {\r\n    //constants\r\n    val TAG = \"BTService\"\r\n\r\n    // Member fields\r\n    private var mScanning: Boolean = false\r\n    private var mState: Int = STATE_NONE\r\n    private var mErrorStatus: String = \"\"\r\n    private val mWriteSemaphore: Semaphore = Semaphore(1)\r\n    private val mReadQueue = ConcurrentLinkedQueue<ByteArray>()\r\n    private val mWriteQueue = ConcurrentLinkedQueue<ByteArray>()\r\n    private var mBluetoothGatt: BluetoothGatt? = null\r\n    private var mBluetoothDevice: BluetoothDevice? = null\r\n    private var mConnectionThread: ConnectionThread? = null\r\n    private var mLogWriteState: Boolean = false\r\n\r\n    //Gatt additional properties\r\n    private fun BluetoothGattCharacteristic.isReadable(): Boolean = containsProperty(BluetoothGattCharacteristic.PROPERTY_READ)\r\n    private fun BluetoothGattCharacteristic.isWritable(): Boolean = containsProperty(BluetoothGattCharacteristic.PROPERTY_WRITE)\r\n    private fun BluetoothGattCharacteristic.isWritableWithoutResponse(): Boolean = containsProperty(BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE)\r\n    private fun BluetoothGattCharacteristic.isIndicatable(): Boolean = containsProperty(BluetoothGattCharacteristic.PROPERTY_INDICATE)\r\n    private fun BluetoothGattCharacteristic.isNotifiable(): Boolean = containsProperty(BluetoothGattCharacteristic.PROPERTY_NOTIFY)\r\n    private fun BluetoothGattCharacteristic.containsProperty(property: Int): Boolean = properties and property != 0\r\n\r\n    override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int {\r\n        super.onStartCommand(intent, flags, startId)\r\n\r\n        when (intent.action) {\r\n            BT_START_SERVICE.toString() -> {\r\n                doStartService()\r\n            }\r\n            BT_STOP_SERVICE.toString() -> {\r\n                doStopService()\r\n            }\r\n            BT_DO_CONNECT.toString() -> {\r\n                doConnect()\r\n            }\r\n            BT_DO_DISCONNECT.toString() -> {\r\n                doDisconnect()\r\n            }\r\n            BT_DO_CHECK_VIN.toString() -> {\r\n                mConnectionThread?.setTaskState(TASK_RD_VIN)\r\n            }\r\n            BT_DO_CHECK_PID.toString() -> {\r\n                mConnectionThread?.setTaskState(TASK_LOGGING)\r\n            }\r\n            BT_DO_STOP_PID.toString() -> {\r\n                mConnectionThread?.setTaskState(TASK_NONE)\r\n            }\r\n            BT_DO_CLEAR_DTC.toString() -> {\r\n                mConnectionThread?.setTaskState(TASK_CLEAR_DTC)\r\n            }\r\n        }\r\n\r\n        // If we get killed, after returning from here, restart\r\n        return START_STICKY\r\n    }\r\n\r\n    override fun onBind(intent: Intent): IBinder? {\r\n        // We don't provide binding, so return null\r\n        return null\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n        Toast.makeText(this, \"service done\", Toast.LENGTH_SHORT).show()\r\n        doDisconnect()\r\n    }\r\n\r\n    private val mScanCallback = object : ScanCallback() {\r\n        val TAG = \"mScanCallback\"\r\n\r\n        override fun onScanResult(callbackType: Int, result: ScanResult) {\r\n            super.onScanResult(callbackType, result)\r\n            result.device?.let { device ->\r\n                Log.i(TAG, \"Found BLE device! ${device.name}\")\r\n\r\n                if (mBluetoothDevice == null && device.name.contains(BLE_DEVICE_NAME, true)) {\r\n                    mBluetoothDevice = device\r\n\r\n                    if (mScanning)\r\n                        stopScanning()\r\n\r\n                    Log.i(TAG, \"Initiating connection to ${device.name}\")\r\n                    device.connectGatt(applicationContext, false, mGattCallback, 2)\r\n                }\r\n            }\r\n        }\r\n\r\n        override fun onScanFailed(errorCode: Int) {\r\n            super.onScanFailed(errorCode)\r\n            Log.e(TAG, \"onScanFailed: code $errorCode\")\r\n        }\r\n    }\r\n\r\n    private val mGattCallback = object : BluetoothGattCallback() {\r\n        val TAG = \"BTGATTCallback\"\r\n\r\n        override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {\r\n            super.onConnectionStateChange(gatt, status, newState)\r\n            val deviceAddress = gatt.device.address\r\n\r\n            if (status == BluetoothGatt.GATT_SUCCESS) {\r\n                if (newState == BluetoothProfile.STATE_CONNECTED) {\r\n                    Log.w(TAG, \"Successfully connected to $deviceAddress\")\r\n\r\n                    //made connection, store our gatt\r\n                    mBluetoothGatt = gatt\r\n\r\n                    try {\r\n                        //discover gatt table\r\n                        mBluetoothGatt?.let { newGatt ->\r\n                            Handler(Looper.getMainLooper()).post {\r\n                                newGatt.discoverServices()\r\n                            }\r\n                        } ?: error(\"Gatt is invalid\")\r\n                    } catch (e: Exception) {\r\n                        Log.e(TAG,\"Exception requesting to discover services\", e)\r\n                        doDisconnect()\r\n                    }\r\n                } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {\r\n                    Log.w(TAG, \"Successfully disconnected from $deviceAddress\")\r\n\r\n                    //disable the read notification\r\n                    disableNotifications(gatt.getService(BLE_SERVICE_UUID).getCharacteristic(BLE_DATA_RX_UUID))\r\n\r\n                    //If gatt doesn't match ours make sure we close it\r\n                    if(gatt != mBluetoothGatt) {\r\n                        gatt.close()\r\n                    }\r\n\r\n                    //Do a full disconnect\r\n                    doDisconnect()\r\n                }\r\n            } else {\r\n                Log.w(TAG, \"Error $status encountered for $deviceAddress! Disconnecting...\")\r\n\r\n                //If gatt doesn't match ours make sure we close it\r\n                if(gatt != mBluetoothGatt) {\r\n                    gatt.close()\r\n                }\r\n\r\n                //Set new connection error state\r\n                mErrorStatus = status.toString()\r\n\r\n                //Do a full disconnect\r\n                doDisconnect(STATE_ERROR, true)\r\n            }\r\n        }\r\n\r\n        override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {\r\n            super.onServicesDiscovered(gatt, status)\r\n            if(status == BluetoothGatt.GATT_SUCCESS) {\r\n                with(gatt) {\r\n                    Log.w(TAG, \"Discovered ${services.size} services for ${device.address}\")\r\n                    printGattTable()\r\n                    try {\r\n                        mBluetoothGatt?.requestMtu(BLE_GATT_MTU_SIZE) ?: error(\"Gatt is invalid\")\r\n                    } catch (e: Exception) {\r\n                        Log.e(TAG,\"Exception while discovering services\", e)\r\n                        doDisconnect()\r\n                    }\r\n                }\r\n            } else {\r\n                //If gatt doesn't match ours make sure we close it\r\n                if(gatt != mBluetoothGatt) {\r\n                    gatt.close()\r\n                }\r\n\r\n                //Set new connection error state\r\n                mErrorStatus = status.toString()\r\n\r\n                //Do a full disconnect\r\n                doDisconnect(STATE_ERROR, true)\r\n            }\r\n        }\r\n\r\n        override fun onMtuChanged(gatt: BluetoothGatt, mtu: Int, status: Int) {\r\n            super.onMtuChanged(gatt, mtu, status)\r\n            Log.w(TAG,\"ATT MTU changed to $mtu, success: ${status == BluetoothGatt.GATT_SUCCESS}\")\r\n\r\n            if(status == BluetoothGatt.GATT_SUCCESS) {\r\n                //Set new connection state\r\n                setConnectionState(STATE_CONNECTED)\r\n                try {\r\n                    mBluetoothGatt?.let { ourGatt ->\r\n                        ourGatt.requestConnectionPriority(BLE_CONNECTION_PRIORITY)\r\n                        enableNotifications(ourGatt.getService(BLE_SERVICE_UUID)!!.getCharacteristic(BLE_DATA_RX_UUID))\r\n                    } ?: error(\"Gatt is invalid\")\r\n                } catch (e: Exception) {\r\n                    Log.e(TAG,\"Exception setting mtu\", e)\r\n                    doDisconnect()\r\n                }\r\n            } else {\r\n                //If gatt doesn't match ours make sure we close it\r\n                if(gatt != mBluetoothGatt) {\r\n                    gatt.close()\r\n                }\r\n\r\n                //Set new connection error state\r\n                mErrorStatus = status.toString()\r\n\r\n                //Do a full disconnect\r\n                doDisconnect(STATE_ERROR, true)\r\n            }\r\n        }\r\n\r\n        override fun onDescriptorWrite(gatt: BluetoothGatt?, descriptor: BluetoothGattDescriptor?, status: Int) {\r\n            super.onDescriptorWrite(gatt, descriptor, status)\r\n            when (status) {\r\n                BluetoothGatt.GATT_SUCCESS -> {\r\n                    Log.d(\"onDescWrite\", \"success ${descriptor.toString()}\")\r\n                }\r\n                else -> {\r\n                    Log.d(\"onDescWrite\", \"failed ${descriptor.toString()}\")\r\n                }\r\n            }\r\n        }\r\n\r\n        override fun onCharacteristicRead(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic, status: Int) {\r\n            super.onCharacteristicRead(gatt, characteristic, status)\r\n            with(characteristic) {\r\n                when (status) {\r\n                    BluetoothGatt.GATT_SUCCESS -> {\r\n                        Log.i(TAG, \"Read characteristic $uuid:\\n${value}\")\r\n                    }\r\n                    BluetoothGatt.GATT_READ_NOT_PERMITTED -> {\r\n                        Log.e(TAG, \"Read not permitted for $uuid!\")\r\n                    }\r\n                    else -> {\r\n                        Log.e(TAG, \"Characteristic read failed for $uuid, error: $status\")\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        override fun onCharacteristicWrite(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic, status: Int) {\r\n            super.onCharacteristicWrite(gatt, characteristic, status)\r\n            with(characteristic) {\r\n                when (status) {\r\n                    BluetoothGatt.GATT_SUCCESS -> {\r\n                        Log.i(\"BluetoothGattCallback\", \"Wrote to characteristic $uuid | value: $value\")\r\n                    }\r\n                    BluetoothGatt.GATT_INVALID_ATTRIBUTE_LENGTH -> {\r\n                        Log.e(\"BluetoothGattCallback\", \"Write exceeded connection ATT MTU!\")\r\n                    }\r\n                    BluetoothGatt.GATT_WRITE_NOT_PERMITTED -> {\r\n                        Log.e(\"BluetoothGattCallback\", \"Write not permitted for $uuid!\")\r\n                    }\r\n                    else -> {\r\n                        Log.e(\"BluetoothGattCallback\", \"Characteristic write failed for $uuid, error: $status\")\r\n                    }\r\n                }\r\n            }\r\n            mWriteSemaphore.release()\r\n        }\r\n\r\n        override fun onCharacteristicChanged(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic) {\r\n            super.onCharacteristicChanged(gatt, characteristic)\r\n            with(characteristic) {\r\n                Log.i(\"BluetoothGattCallback\", \"Characteristic $uuid changed | value: $value\")\r\n\r\n                //parse packet and check for multiple responses\r\n                val bleHeader = BLEHeader()\r\n                while(value.count() > 0) {\r\n                    bleHeader.fromByteArray(value)\r\n                    value = if(bleHeader.cmdSize+8 <= value.count()) {\r\n                        mReadQueue.add(value.copyOfRange(0, bleHeader.cmdSize + 8))\r\n                        value.copyOfRange(bleHeader.cmdSize + 8, value.count())\r\n                    } else {\r\n                        byteArrayOf()\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun BluetoothGatt.printGattTable() {\r\n        if (services.isEmpty()) {\r\n            Log.i(\"printGattTable\", \"No service and characteristic available, call discoverServices() first?\")\r\n            return\r\n        }\r\n        services.forEach { service ->\r\n            val characteristicsTable = service.characteristics.joinToString(separator = \"\\n|--\", prefix = \"|--\") {\r\n                it.uuid.toString()\r\n            }\r\n            Log.i(\"printGattTable\", \"\\nService ${service.uuid}\\nCharacteristics:\\n$characteristicsTable\")\r\n        }\r\n    }\r\n\r\n    private fun writeDescriptor(descriptor: BluetoothGattDescriptor, payload: ByteArray) {\r\n        mBluetoothGatt?.let { gatt ->\r\n            descriptor.value = payload\r\n            gatt.writeDescriptor(descriptor)\r\n        } ?: error(\"Not connected to a BLE device!\")\r\n    }\r\n\r\n    private fun enableNotifications(characteristic: BluetoothGattCharacteristic) {\r\n        val payload = when {\r\n            characteristic.isIndicatable() -> BluetoothGattDescriptor.ENABLE_INDICATION_VALUE\r\n            characteristic.isNotifiable() -> BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE\r\n            else -> {\r\n                Log.e(\"ConnectionManager\", \"${characteristic.uuid} doesn't support notifications/indications\")\r\n                return\r\n            }\r\n        }\r\n\r\n        characteristic.getDescriptor(BLE_CCCD_UUID)?.let { cccDescriptor ->\r\n            if (mBluetoothGatt?.setCharacteristicNotification(characteristic, true) == false) {\r\n                Log.e(\"ConnectionManager\", \"setCharacteristicNotification failed for ${characteristic.uuid}\")\r\n                return\r\n            }\r\n            writeDescriptor(cccDescriptor, payload)\r\n        } ?: Log.e(\"ConnectionManager\", \"${characteristic.uuid} doesn't contain the CCC descriptor!\")\r\n    }\r\n\r\n    private fun disableNotifications(characteristic: BluetoothGattCharacteristic) {\r\n        if (!characteristic.isNotifiable() && !characteristic.isIndicatable()) {\r\n            Log.e(\"ConnectionManager\", \"${characteristic.uuid} doesn't support indications/notifications\")\r\n            return\r\n        }\r\n\r\n        characteristic.getDescriptor(BLE_CCCD_UUID)?.let { cccDescriptor ->\r\n            if (mBluetoothGatt?.setCharacteristicNotification(characteristic, false) == false) {\r\n                Log.e(\"ConnectionManager\", \"setCharacteristicNotification failed for ${characteristic.uuid}\")\r\n                return\r\n            }\r\n            writeDescriptor(cccDescriptor, BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE)\r\n        } ?: Log.e(\"ConnectionManager\", \"${characteristic.uuid} doesn't contain the CCC descriptor!\")\r\n    }\r\n\r\n    @Synchronized\r\n    private fun stopScanning() {\r\n        Log.i(TAG, \"Stop Scanning\")\r\n        if (mScanning) {\r\n            (getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager).adapter.bluetoothLeScanner.stopScan(mScanCallback)\r\n            mScanning = false\r\n        }\r\n    }\r\n\r\n    @Synchronized\r\n    private fun doStopService() {\r\n        LogFile.close()\r\n        doDisconnect()\r\n        stopForeground(true)\r\n        stopSelf() //test\r\n    }\r\n\r\n    @Synchronized\r\n    private fun doStartService() {\r\n        val serviceChannel = NotificationChannel(CHANNEL_ID, CHANNEL_NAME, NotificationManager.IMPORTANCE_DEFAULT)\r\n        val manager = getSystemService(NotificationManager::class.java)\r\n        manager.createNotificationChannel(serviceChannel)\r\n\r\n        val notificationIntent = Intent(this, MainActivity::class.java)\r\n        val pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0)\r\n\r\n        val notification: Notification = Notification.Builder(this, CHANNEL_ID)\r\n            .setContentTitle(getText(R.string.app_name))\r\n            .setContentText(getText(R.string.app_name))\r\n            .setSmallIcon(R.drawable.ic_launcher_foreground)\r\n            .setContentIntent(pendingIntent)\r\n            .build()\r\n\r\n        // Notification ID cannot be 0.\r\n        startForeground(1, notification)\r\n    }\r\n\r\n    @Synchronized\r\n    private fun doConnect() {\r\n        doDisconnect()\r\n\r\n        Log.w(TAG, \"Searching for BLE device.\")\r\n\r\n        val filter = listOf(\r\n            ScanFilter.Builder().setServiceUuid(ParcelUuid.fromString(BLE_SERVICE_UUID.toString()))\r\n                .build()\r\n        )\r\n        val settings = ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build()\r\n\r\n        //set delay to stop scanning\r\n        Handler(Looper.getMainLooper()).postDelayed({\r\n            doTimeout()\r\n        }, BLE_SCAN_PERIOD)\r\n\r\n        //Set new connection status\r\n        setConnectionState(STATE_CONNECTING)\r\n\r\n        //Start scanning for BLE devices\r\n        (getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager).adapter.bluetoothLeScanner.startScan(filter, settings, mScanCallback)\r\n        mScanning = true\r\n    }\r\n\r\n    @Synchronized\r\n    private fun doDisconnect(newState: Int = STATE_NONE, errorMessage: Boolean = false) {\r\n        Log.w(TAG, \"Disconnecting from BLE device.\")\r\n        if (mScanning)\r\n            stopScanning()\r\n\r\n        closeConnectionThread()\r\n\r\n        if (mBluetoothGatt != null) {\r\n            mBluetoothGatt!!.close()\r\n            mBluetoothGatt = null\r\n        }\r\n\r\n        mBluetoothDevice = null\r\n\r\n        //Set new connection status\r\n        setConnectionState(newState, errorMessage)\r\n    }\r\n\r\n    @Synchronized\r\n    private fun doTimeout() {\r\n        if(mScanning)\r\n            stopScanning()\r\n\r\n        if(mState != STATE_CONNECTED) {\r\n            //Set new connection status\r\n            setConnectionState(STATE_NONE)\r\n        }\r\n    }\r\n\r\n    @Synchronized\r\n    private fun closeConnectionThread() {\r\n        if(mConnectionThread != null) {\r\n            mConnectionThread!!.cancel()\r\n            mConnectionThread = null\r\n        }\r\n    }\r\n\r\n    @Synchronized\r\n    private fun createConnectionThread() {\r\n        mConnectionThread = ConnectionThread()\r\n        mConnectionThread?.priority = THREAD_PRIORITY_CONNECTION\r\n        mConnectionThread?.start()\r\n    }\r\n\r\n    @Synchronized\r\n    private fun setConnectionState(newState: Int, errorMessage: Boolean = false)\r\n    {\r\n        when(newState) {\r\n            STATE_CONNECTED -> {\r\n                closeConnectionThread()\r\n                createConnectionThread()\r\n            }\r\n            STATE_NONE -> {\r\n                closeConnectionThread()\r\n            }\r\n            STATE_ERROR -> {\r\n                closeConnectionThread()\r\n            }\r\n        }\r\n        //Broadcast a new message\r\n        mState = newState\r\n        val intentMessage = Intent(MESSAGE_STATE_CHANGE.toString())\r\n        intentMessage.putExtra(\"newState\", mState)\r\n        intentMessage.putExtra(\"cDevice\", mBluetoothGatt?.device?.name)\r\n        if(errorMessage)\r\n            intentMessage.putExtra(\"newError\", mErrorStatus)\r\n        sendBroadcast(intentMessage)\r\n    }\r\n\r\n    private inner class ConnectionThread: Thread() {\r\n        //variables\r\n        private var mTask: Int = TASK_NONE\r\n        private var mTaskCount: Int = 0\r\n        private var mTaskTime: Long = 0\r\n        private var mLogFile: File? = null\r\n        private var mBufferedWriter: BufferedWriter? = null\r\n\r\n        init {\r\n            setTaskState(TASK_NONE)\r\n            Log.d(TAG, \"create ConnectionThread\")\r\n        }\r\n\r\n        override fun run() {\r\n            Log.i(TAG, \"BEGIN mConnectionThread\")\r\n            logCreate()\r\n\r\n            while (mState == STATE_CONNECTED && !currentThread().isInterrupted) {\r\n                //See if there are any packets waiting to be sent\r\n                if (!mWriteQueue.isEmpty() && mWriteSemaphore.tryAcquire()) {\r\n                    try {\r\n                        val txChar = mBluetoothGatt!!.getService(BLE_SERVICE_UUID)!!\r\n                            .getCharacteristic(BLE_DATA_TX_UUID)\r\n                        val writeType = when {\r\n                            txChar.isWritable() -> BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT\r\n                            txChar.isWritableWithoutResponse() -> BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE\r\n                            else -> error(\"Characteristic ${txChar.uuid} cannot be written to\")\r\n                        }\r\n\r\n                        val buff = mWriteQueue.poll()\r\n                        if(buff != null)\r\n                            logAdd(true, buff)\r\n\r\n                        mBluetoothGatt?.let { gatt ->\r\n                            txChar.writeType = writeType\r\n                            txChar.value = buff\r\n                            gatt.writeCharacteristic(txChar)\r\n                        } ?: error(\"Not connected to a BLE device!\")\r\n                    } catch (e: Exception) {\r\n                        Log.e(TAG, \"Exception during write\", e)\r\n                        mWriteSemaphore.release()\r\n                        cancel()\r\n                        break\r\n                    }\r\n                }\r\n\r\n                //See if there are any packets waiting to be sent\r\n                if (!mReadQueue.isEmpty()) {\r\n                    try {\r\n                        val buff = mReadQueue.poll()\r\n                        if(buff != null)\r\n                            logAdd(false, buff)\r\n                        \r\n                        when (mTask) {\r\n                            TASK_NONE -> {\r\n                                //Broadcast a new message\r\n                                val intentMessage = Intent(MESSAGE_READ.toString())\r\n                                intentMessage.putExtra(\"readBuffer\", buff)\r\n                                sendBroadcast(intentMessage)\r\n                            }\r\n                            TASK_RD_VIN -> {\r\n                                //Broadcast a new message\r\n                                val intentMessage = Intent(MESSAGE_READ_VIN.toString())\r\n                                intentMessage.putExtra(\"readBuffer\", buff)\r\n                                sendBroadcast(intentMessage)\r\n\r\n                                setTaskState(TASK_NONE)\r\n                            }\r\n                            TASK_CLEAR_DTC -> {\r\n                                if(mTaskCount == 1) {\r\n                                    //Broadcast a new message\r\n                                    val intentMessage = Intent(MESSAGE_READ_DTC.toString())\r\n                                    intentMessage.putExtra(\"readBuffer\", buff)\r\n                                    sendBroadcast(intentMessage)\r\n\r\n                                    setTaskState(TASK_NONE)\r\n                                }\r\n                            }\r\n                            TASK_LOGGING -> {\r\n                                mTaskCount++\r\n\r\n                                //Process frame\r\n                                val result = UDSLogger.processFrame(mTaskCount, buff, applicationContext)\r\n\r\n                                //Are we still sending initial frames?\r\n                                if(mTaskCount < UDSLogger.frameCount()) {\r\n                                    //If we failed init abort\r\n                                    if(result != UDS_OK) {\r\n                                        setTaskState(TASK_NONE)\r\n                                    } else { //else continue init\r\n                                        mWriteQueue.add(UDSLogger.buildFrame(mTaskCount))\r\n                                    }\r\n                                }\r\n\r\n                                //Broadcast a new message\r\n                                if(mTaskCount % Settings.updateRate == 0) {\r\n                                    val intentMessage = Intent(MESSAGE_READ_LOG.toString())\r\n                                    intentMessage.putExtra(\"readCount\", mTaskCount)\r\n                                    intentMessage.putExtra(\"readTime\", System.currentTimeMillis() - mTaskTime)\r\n                                    intentMessage.putExtra(\"readResult\", result)\r\n                                    sendBroadcast(intentMessage)\r\n                                }\r\n\r\n                                //If we changed logging write states broadcast a new message and set LED color\r\n                                if(UDSLogger.isEnabled() != mLogWriteState) {\r\n                                    //Broadcast new message\r\n                                    val intentMessage = Intent(MESSAGE_WRITE_LOG.toString())\r\n                                    intentMessage.putExtra(\"enabled\", UDSLogger.isEnabled())\r\n                                    sendBroadcast(intentMessage)\r\n\r\n                                    //Set LED\r\n                                    val bleHeader = BLEHeader()\r\n                                    bleHeader.cmdSize = 4\r\n                                    bleHeader.cmdFlags = BLE_COMMAND_FLAG_SETTINGS or BRG_SETTING_LED_COLOR\r\n                                    var dataBytes = byteArrayOf(0x00.toByte(), 0x00.toByte(), 0x80.toByte(), 0x00.toByte())\r\n                                    if(UDSLogger.isEnabled())\r\n                                        dataBytes = byteArrayOf(0x00.toByte(), 0x80.toByte(), 0x00.toByte(), 0x00.toByte())\r\n                                    val buf = bleHeader.toByteArray() + dataBytes\r\n                                    mWriteQueue.add(buf)\r\n\r\n                                    //Update current write state\r\n                                    mLogWriteState = UDSLogger.isEnabled()\r\n                                }\r\n                            }\r\n                        }\r\n                    } catch (e: Exception) {\r\n                        Log.e(TAG, \"Exception during read\", e)\r\n                        cancel()\r\n                        break\r\n                    }\r\n                }\r\n            }\r\n            logClose()\r\n        }\r\n\r\n        fun cancel() {\r\n            interrupt()\r\n        }\r\n\r\n        fun setTaskState(newTask: Int)\r\n        {\r\n            if (mState != STATE_CONNECTED) {\r\n                mTask = TASK_NONE\r\n                return\r\n            }\r\n\r\n            //Broadcast a new message\r\n            mTaskCount = 0\r\n            mTaskTime = System.currentTimeMillis()\r\n            mTask = newTask\r\n            val intentMessage = Intent(MESSAGE_TASK_CHANGE.toString())\r\n            intentMessage.putExtra(\"newTask\", mTask)\r\n            sendBroadcast(intentMessage)\r\n\r\n            when (mTask) {\r\n                TASK_LOGGING -> {\r\n                    //Set persist delay\r\n                    val bleHeader = BLEHeader()\r\n                    bleHeader.cmdSize = 2\r\n                    bleHeader.cmdFlags = BLE_COMMAND_FLAG_SETTINGS or BRG_SETTING_PERSIST_DELAY\r\n                    var dataBytes = byteArrayOf((Settings.persistDelay and 0xFF).toByte(), ((Settings.persistDelay and 0xFF00) shr 8).toByte())\r\n                    var buf = bleHeader.toByteArray() + dataBytes\r\n                    mWriteQueue.add(buf)\r\n\r\n                    //Set persist Q delay\r\n                    bleHeader.cmdSize = 2\r\n                    bleHeader.cmdFlags = BLE_COMMAND_FLAG_SETTINGS or BRG_SETTING_PERSIST_Q_DELAY\r\n                    dataBytes = byteArrayOf((Settings.persistQDelay and 0xFF).toByte(), ((Settings.persistQDelay and 0xFF00) shr 8).toByte())\r\n                    buf = bleHeader.toByteArray() + dataBytes\r\n                    mWriteQueue.add(buf)\r\n\r\n                    //Set st_min\r\n                    bleHeader.cmdSize = 2\r\n                    bleHeader.cmdFlags = BLE_COMMAND_FLAG_SETTINGS or BRG_SETTING_ISOTP_STMIN\r\n                    dataBytes = byteArrayOf(0x5E.toByte(), 0x01.toByte())\r\n                    buf = bleHeader.toByteArray() + dataBytes\r\n                    mWriteQueue.add(buf)\r\n\r\n                    //Write first frame\r\n                    mWriteQueue.add(UDSLogger.buildFrame(0))\r\n                }\r\n                TASK_RD_VIN -> {\r\n                    val bleHeader = BLEHeader()\r\n                    bleHeader.cmdSize = 3\r\n                    bleHeader.cmdFlags = BLE_COMMAND_FLAG_PER_CLEAR\r\n                    val dataBytes = byteArrayOf(0x22.toByte(), 0xF1.toByte(), 0x90.toByte())\r\n                    val buf = bleHeader.toByteArray() + dataBytes\r\n                    mWriteQueue.add(buf)\r\n                }\r\n                TASK_CLEAR_DTC -> {\r\n                    //Set st_min\r\n                    val bleHeader = BLEHeader()\r\n                    bleHeader.cmdSize = 2\r\n                    bleHeader.cmdFlags = BLE_COMMAND_FLAG_SETTINGS or BRG_SETTING_ISOTP_STMIN\r\n                    var dataBytes = byteArrayOf(0x5E.toByte(), 0x01.toByte())\r\n                    var buf = bleHeader.toByteArray() + dataBytes\r\n                    mWriteQueue.add(buf)\r\n\r\n                    //Send clear request\r\n                    bleHeader.rxID = 0x7E8\r\n                    bleHeader.txID = 0x700\r\n                    bleHeader.cmdSize = 1\r\n                    bleHeader.cmdFlags = BLE_COMMAND_FLAG_PER_CLEAR\r\n                    dataBytes = byteArrayOf(0x04.toByte())\r\n                    buf = bleHeader.toByteArray() + dataBytes\r\n                    mWriteQueue.add(buf)\r\n                }\r\n                TASK_NONE -> {\r\n                    //Clear any persist messages\r\n                    val bleHeader = BLEHeader()\r\n                    bleHeader.cmdFlags = BLE_COMMAND_FLAG_PER_CLEAR\r\n                    mWriteQueue.add(bleHeader.toByteArray())\r\n\r\n                    //Set LED to green\r\n                    bleHeader.cmdSize = 4\r\n                    bleHeader.cmdFlags = BLE_COMMAND_FLAG_SETTINGS or BRG_SETTING_LED_COLOR\r\n                    val dataBytes = byteArrayOf(0x00.toByte(), 0x00.toByte(), 0x80.toByte(), 0x00.toByte())\r\n                    val buf = bleHeader.toByteArray() + dataBytes\r\n                    mWriteQueue.add(buf)\r\n                }\r\n            }\r\n        }\r\n\r\n        private fun logCreate() {\r\n            if(!LOG_COMMUNICATIONS)\r\n                return\r\n\r\n            logClose()\r\n\r\n            val path = applicationContext.getExternalFilesDir(\"\")\r\n            Log.i(TAG, \"$path/data.log\")\r\n            mLogFile = File(path, \"/data.log\")\r\n            if(mLogFile == null)\r\n                return\r\n\r\n            try {\r\n                mLogFile!!.createNewFile()\r\n                mBufferedWriter = BufferedWriter(FileWriter(mLogFile, true))\r\n            } catch (e: Exception) {\r\n                e.printStackTrace()\r\n            }\r\n        }\r\n\r\n        private fun logClose() {\r\n            if(!LOG_COMMUNICATIONS)\r\n                return\r\n\r\n            if(mBufferedWriter != null) {\r\n                mBufferedWriter!!.close()\r\n                mBufferedWriter = null\r\n            }\r\n\r\n            mLogFile = null\r\n        }\r\n\r\n        private fun logAdd(from: Boolean, buff: ByteArray?) {\r\n            if(!LOG_COMMUNICATIONS)\r\n                return\r\n\r\n            if(mLogFile == null || mBufferedWriter == null || buff == null)\r\n                return\r\n\r\n            try {\r\n                if(from) mBufferedWriter!!.append(\"->[${buff.count()}]:${buff.toHex()}\")\r\n                else mBufferedWriter!!.append(\"<-[${buff.count()}]:${buff.toHex()}\")\r\n                mBufferedWriter!!.newLine()\r\n            } catch (e: Exception) {\r\n                e.printStackTrace()\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/app/simoslogger/BTService.kt b/app/src/main/java/com/app/simoslogger/BTService.kt
--- a/app/src/main/java/com/app/simoslogger/BTService.kt	(revision 0bb28e4c639684bb3a2fa891a6885a9f165cf3cd)
+++ b/app/src/main/java/com/app/simoslogger/BTService.kt	(date 1633817879532)
@@ -404,7 +404,7 @@
         LogFile.close()
         doDisconnect()
         stopForeground(true)
-        stopSelf() //test
+        stopSelf()
     }
 
     @Synchronized
